# Licensed to the .NET Foundation under one or more agreements. The .NET Foundation licenses this file to you under the MIT license. See the LICENSE.md file in the project root for more information.

jobs:
- job: BuildOfficialRelease
  displayName: Build Official Release
  # We make this timeout more than double the normal amount of build time as signing has a highly variable amount of time to complete.
  timeoutInMinutes: 90
  steps:

  ###################################################################################################################################################################
  # SBOM GENERATION
  # This process occurs above plugin installation so that the Src build does not perform signing.
  ###################################################################################################################################################################

  # Use a disabled, empty script to display the section header in the pipeline UI.
  - script:
    displayName: === SBOM Generation ===
    condition: false

  # Only the projects in the 'src' folder are necessary for generating the SBOM.
  - script: $(Build.SourcesDirectory)/build.cmd /v:normal /p:Configuration=$(BuildConfiguration) /p:CIBuild=true /p:Test=false /p:Pack=false /p:TestProjects=false /p:SetupProjects=false
    displayName: Build Src Projects

  # The binlog is set to Build.binlog by default when using build.cmd. We rename it so it isn't overridden by the full build.
  - powershell: Rename-Item -Path '$(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/log/Build.binlog' -NewName SrcBuild.binlog
    displayName: Rename Src Binlog

  # This task both generates the SBOM files and marks the pipeline as compliant.
  # The SBOM files are needed prior to the full build, as the full build includes them within the .vsman insertion files as part of the SwixBuild (.vsmanproj) process.
  - task: ManifestGeneratorTask@0
    displayName: Generate SBOM
    inputs:
      BuildDropPath: $(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/bin/Dlls
      ManifestDirPath: $(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/bin

  ###################################################################################################################################################################
  # PLUGIN INSTALLATION
  ###################################################################################################################################################################

  # Use a disabled, empty script to display the section header in the pipeline UI.
  - script:
    displayName: === Plugin Installation ===
    condition: false

  # Necessary for signing the assemblies and packages.
  - task: MicroBuildSigningPlugin@4
    displayName: Install Signing Plugin
    inputs:
      # Build fails if this is set to 'test'.
      # See: https://github.com/dotnet/project-system/issues/7935
      signType: real
      esrpSigning: true

  # Gets the signconfig.xml from the MicroBuild Signing plugin and sets the retry interval to 45 seconds.
  # This reduces the calls to the signing API (potentially increasing signing speed) and reduces the pipeline log bloat when polling signing completion.
  - powershell: . '$(Build.SourcesDirectory)/eng/scripts/SetSigningRetryInterval.ps1' -signConfigPath ((Get-ChildItem -Path '$(Build.StagingDirectory)/MicroBuild/Plugins/*/build/signconfig.xml').FullName) -intervalInSeconds 45
    displayName: Set Signing Interval
    # This is not a necessary task for the build to be successful.
    continueOnError: true

  # Necessary for building the .swixproj (VSIX package) and .vsmanproj (VS Insertion) projects.
  - task: MicroBuildSwixPlugin@4
    displayName: Install Swix Plugin

  # This requires the OptimizationInputs via the 'Publish OptimizationInputs drop' step in the release pipeline.
  # To generate ProfilingInputs for the first time, set this input: ShouldSkipOptimize: true
  # See documentation here: https://devdiv.visualstudio.com/DevDiv/_wiki/wikis/DevDiv.wiki/2602/Build-With-Expired-(or-Without-Prior)-Optimization-Profiling-Data
  # This plugin will restore MicroBuild.Plugins.OptProf which is required to create ProfilingInputs data.
  # The projects include OptProf.targets which uses MicroBuild.Plugins.OptProf to run the target GenerateProfilingInputs on each project.
  - task: MicroBuildOptProfPlugin@6
    displayName: Install OptProf Plugin
    inputs:
      ProfilingInputsDropName: ProfilingInputs/$(System.TeamProject)/$(Build.Repository.Name)/$(Build.SourceBranchName)/$(Build.BuildId)
      OptimizationInputsLookupMethod: DropPrefix
      DropNamePrefix: OptimizationInputs/$(System.TeamProject)/$(Build.Repository.Name)
      AccessToken: $(System.AccessToken)
      feedSource: https://devdiv.pkgs.visualstudio.com/DefaultCollection/_packaging/MicroBuildToolset/nuget/v3/index.json
      ShouldSkipOptimize: $(SkipOptimize)
      # This value determines how old the optimization data is allowed to be.
      # If the delta of the number of commits between the commit used for the last produced optimization data and the current commit is greater than this value,
      # this task will always fail. The only way to fix it is produce new optimization data.
      # A temporary fix is to increase this value. However, it may cause a perf regression since eventually, the optimization data will no longer be aligned with the actual source content in the repo.
      NumberCommitsToSearch: 100

  ###################################################################################################################################################################
  # BUILD REPOSITORY
  ###################################################################################################################################################################

  # Use a disabled, empty script to display the section header in the pipeline UI.
  - script:
    displayName: === Build Repository ===
    condition: false

  # Runs the full build of the projects in the repository. See Build.proj for details.
  - script: $(Build.SourcesDirectory)/build.cmd /v:normal /p:Configuration=$(BuildConfiguration) /p:CIBuild=true
    displayName: Build All Projects

  # Sets the PackageVersion variable for the job. This variable is not used by this job; instead, it is consumed by the Insertion job.
  # https://docs.microsoft.com/azure/devops/pipelines/process/set-variables-scripts?view=azure-devops&tabs=powershell#set-variable-properties
  - powershell: Write-Host "##vso[task.setvariable variable=PackageVersion;isoutput=true]$(NBGV_NuGetPackageVersion)"
    displayName: Set PackageVersion Variable
    # Name is required to reference the variables created within this build step in other stages.
    name: SetPackageVersion

  # Sets the AssemblyVersion variable for the job. This variable is not used by this job; instead, it is consumed by the Insertion job.
  # https://docs.microsoft.com/azure/devops/pipelines/process/set-variables-scripts?view=azure-devops&tabs=powershell#set-variable-properties
  - powershell: Write-Host "##vso[task.setvariable variable=AssemblyVersion;isoutput=true]$(NBGV_AssemblyVersion)"
    displayName: Set AssemblyVersion Variable
    # Name is required to reference the variables created within this build step in other stages.
    name: SetAssemblyVersion

  # Sets the VisualStudioMinimumVersion variable for the job. This variable is also used by the APIScan job.
  # https://docs.microsoft.com/azure/devops/pipelines/process/set-variables-scripts?view=azure-devops&tabs=powershell#set-variable-properties
  - powershell: Write-Host "##vso[task.setvariable variable=VisualStudioMinimumVersion;isoutput=true]$(. '$(Build.SourcesDirectory)/eng/scripts/GetVisualStudioMinimumVersion.ps1')"
    displayName: Set VisualStudioMinimumVersion Variable
    # Name is required to reference the variables created within this build step in other stages.
    name: SetVisualStudioMinimumVersionVariable

  # Creates the VS bootstrapper information based on the build's .vsman file.
  # This bootstrapper information is only used for OptProf currently.
  # Since this data will be output with rest of our insertion files, we produce this data now and publish it in the build artifacts.
  # This task creates 2 assets:
  # - The bootstrapper metadata file: $(Build.StagingDirectory)/MicroBuild/Output/BootstrapperInfo.json
  # - The bootstrapper executable (and associated files): [outputFolder]/bootstrapper
  # This task requires these plugins:
  # - MicroBuildSigningPlugin: uses signjson.exe to sign the manifests
  # - MicroBuildSwixPlugin: uses vsman.exe and sets the environment variable ManifestPublishUrl
  # Documentation: https://devdiv.visualstudio.com/DevDiv/_wiki/wikis/DevDiv.wiki/643/How-to-Build-a-Bootstrapper
  - task: MicroBuildBuildVSBootstrapper@2
    displayName: Build VS Bootstrapper
    inputs:
      bootstrapperCoreVersion: latest
      vsMajorVersion: $(SetVisualStudioMinimumVersionVariable.VisualStudioMinimumVersion)
      channelName: int.main
      manifests: $(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/VSSetup/Insertion/Microsoft.VisualStudio.ProjectSystem.Managed.vsman
      # Outputting to the Insertion folder allows the bootstrapper to be published to the Products drop, along with our insertion files.
      # The merged .vsman (OverlaidInstallerManifest.vsman) created by the bootstrapper assumes the bootstrapper will be output to the same drop (Products) as the insertion files.
      outputFolder: $(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/VSSetup/Insertion

  # Run this task only when the pipeline was ran on a schedule.
  - ${{ if eq(variables['Build.Reason'], 'Schedule') }}:
    # This adds our source information to http://index (which is called Codex).
    # https://github.com/Ref12/Codex
    # This runs after the build because it needs:
    # - source files used in the build (including the generated ones in the obj directory)
    # - binaries (.dll) passed as references
    # - .binlog that ties it all together, describes what happened during the build, and where all the inputs are
    # The task uploads the outputs of the process to the pipeline artifacts as 'CodexOutputs' with the file 'store.zip'.
    # There is a separate process that scans all the Azure Pipelines for this specific artifact on a weekly basis and uploads it to the http://index database.
    - task: Ref12Analyze@0
      displayName: Add Build to Codex
      inputs:
        # Argument information can be found here:
        # - https://github.com/Ref12/Codex/blob/d759c4b44bad0f307ec33319278e62d70cf730f3/src/Codex.Automation.Workflow/Program.cs#L47
        # - https://github.com/Ref12/Codex/blob/d759c4b44bad0f307ec33319278e62d70cf730f3/src/Codex/CodexApplication.cs#L52
        workflowArguments: |
          /sourcesDirectory:$(Build.SourcesDirectory)
          /codexRepoUrl:$(Build.Repository.Uri)
          /repoName:$(Build.Repository.Name)
          /additionalCodexArguments:-bld
          /additionalCodexArguments:$(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/log
          /additionalCodexArguments:-noMsBuildLocator
      # This is a non-critical task, so don't fail the build if it fails.
      continueOnError: true

  # Uploads telemetry to MicroBuild about the MicroBuild components used.
  - task: MicroBuildCleanup@1
    displayName: Send MicroBuild Telemetry
    condition: succeededOrFailed()
    # This is a non-critical task, so don't fail the build if it fails.
    continueOnError: true

  ###################################################################################################################################################################
  # PUBLISH BUILD
  # Steps in this section should contain 'condition: succeededOrFailed()' since these artifacts can be used for analyzing build failures.
  # https://docs.microsoft.com/azure/devops/pipelines/process/tasks?view=azure-devops&tabs=yaml#task-control-options
  ###################################################################################################################################################################

  # Use a disabled, empty script to display the section header in the pipeline UI.
  - script:
    displayName: === Publish Build ===
    condition: false

  # Publishes the test results to the Azure Pipeline itself so they can be viewed in the UI.
  # This needs to be ran after the build, because if the build failed due to a test failure, the test results wouldn't be published.
  - task: PublishTestResults@2
    displayName: Publish Test Results
    inputs:
      testRunner: XUnit
      testResultsFiles: $(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/TestResults/*.xml
      testRunTitle: Unit Test Results
    condition: succeededOrFailed()

  # The .artifactignore file filters the artifacts published from a particular folder.
  # This must be present in the folder we want to publish and be named '.artifactignore'.
  # See: https://docs.microsoft.com/azure/devops/artifacts/reference/artifactignore?view=azure-devops
  - powershell: Copy-Item -Path '$(Build.SourcesDirectory)/eng/pipelines/configuration/build.artifactignore' -Destination '$(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)/.artifactignore'
    displayName: Copy Build Artifact Filter
    condition: succeededOrFailed()

  # Publishes the artifacts folder contents to the Azure Pipeline for use in other jobs/stages.
  # This publish is filtered by the .artifactignore in the 'eng' folder. See that file for more details.
  - publish: $(Build.SourcesDirectory)/artifacts/$(BuildConfiguration)
    displayName: Publish Build Artifacts
    # TODO: Consider using $(GitBuildVersion) instead of $(Build.BuildNumber) as it better correlates the build of the code, instead of the run of the pipeline.
    # Traditionally, this artifact name was used as it was required for the prior VS insertion mechanism.
    # Issue: https://github.com/dotnet/project-system/issues/8431
    artifact: $(Build.BuildNumber)
    condition: succeededOrFailed()

  # The .artifactignore file filters the artifacts published from a particular folder.
  # This must be present in the folder we want to publish and be named '.artifactignore'.
  # See: https://docs.microsoft.com/azure/devops/artifacts/reference/artifactignore?view=azure-devops
  - powershell: Copy-Item -Path '$(Build.SourcesDirectory)/eng/pipelines/configuration/staging.artifactignore' -Destination '$(Build.StagingDirectory)/.artifactignore'
    displayName: Copy Staging Artifact Filter
    condition: succeededOrFailed()

  # Publishes the staging folder contents to the Azure Pipeline for use in other jobs/stages.
  # The Build.StagingDirectory is used by certain plugin outputs, such as MicroBuild and OptProf.
  - publish: $(Build.StagingDirectory)
    displayName: Publish Staging Artifacts
    artifact: Staging
    condition: succeededOrFailed()